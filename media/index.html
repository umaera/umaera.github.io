<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="../book/assets/icons/FollySquare.png" type="image/x-icon">
    <link rel="stylesheet" href="../shared/v2/-FONTS-/fonts.css">
    <title>MyMedia</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: MarkerGothic, sans-serif;
            overflow: hidden;
            user-select: none;
            -moz-user-select: none;
            -webkit-user-drag: none;
        }
        h1{
            color: white;
            position: absolute;
            top: 80%; left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <h1>Totally Unready Page!</h1>
    <canvas id="canvas" width="600" height="600"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const size = 120;
        
        let animationTime = 0;
        const morphDuration = 1500; // 2 seconds per morph
        const totalDuration = morphDuration * 3; // 3 shapes total
        
        let currentColor = getRandomColor();
        let nextColor = getRandomColor();
        
        function getRandomColor() {
            const colors = [
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
                '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
                '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D2B4DE'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }
        
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
        }
        
        function getCirclePoints(numPoints = 60) {
            const points = [];
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * Math.PI * 2;
                points.push({
                    x: centerX + Math.cos(angle) * size,
                    y: centerY + Math.sin(angle) * size
                });
            }
            return points;
        }
        
        function getSquarePoints(numPoints = 60) {
            const points = [];
            const perimeter = 4 * size * 2;
            const sideLength = size * 2;
            
            for (let i = 0; i < numPoints; i++) {
                const t = (i / numPoints) * perimeter;
                let x, y;
                
                if (t < sideLength) {
                    // Top side
                    x = centerX - size + (t / sideLength) * sideLength;
                    y = centerY - size;
                } else if (t < sideLength * 2) {
                    // Right side
                    x = centerX + size;
                    y = centerY - size + ((t - sideLength) / sideLength) * sideLength;
                } else if (t < sideLength * 3) {
                    // Bottom side
                    x = centerX + size - ((t - sideLength * 2) / sideLength) * sideLength;
                    y = centerY + size;
                } else {
                    // Left side
                    x = centerX - size;
                    y = centerY + size - ((t - sideLength * 3) / sideLength) * sideLength;
                }
                
                points.push({ x, y });
            }
            return points;
        }
        
        function getTrianglePoints(numPoints = 60) {
            const points = [];
            const height = size * Math.sqrt(3);
            const vertices = [
                { x: centerX, y: centerY - height * 0.6 },
                { x: centerX + size, y: centerY + height * 0.4 },
                { x: centerX - size, y: centerY + height * 0.4 }
            ];
            
            const perimeter = 3 * size * 2;
            
            for (let i = 0; i < numPoints; i++) {
                const t = (i / numPoints) * perimeter;
                let x, y;
                
                if (t < size * 2) {
                    // First side
                    const ratio = t / (size * 2);
                    x = lerp(vertices[0].x, vertices[1].x, ratio);
                    y = lerp(vertices[0].y, vertices[1].y, ratio);
                } else if (t < size * 4) {
                    // Second side
                    const ratio = (t - size * 2) / (size * 2);
                    x = lerp(vertices[1].x, vertices[2].x, ratio);
                    y = lerp(vertices[1].y, vertices[2].y, ratio);
                } else {
                    // Third side
                    const ratio = (t - size * 4) / (size * 2);
                    x = lerp(vertices[2].x, vertices[0].x, ratio);
                    y = lerp(vertices[2].y, vertices[0].y, ratio);
                }
                
                points.push({ x, y });
            }
            return points;
        }
        
        function morphPoints(points1, points2, t) {
            const morphed = [];
            for (let i = 0; i < points1.length; i++) {
                morphed.push({
                    x: lerp(points1[i].x, points2[i].x, t),
                    y: lerp(points1[i].y, points2[i].y, t)
                });
            }
            return morphed;
        }
        
        function drawShape(points, color) {
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const cycle = animationTime % totalDuration;
            const phase = Math.floor(cycle / morphDuration);
            const t = easeInOutCubic((cycle % morphDuration) / morphDuration);
            
            let fromPoints, toPoints;
            
            // Change color at the start of each morph
            if (Math.floor(animationTime / morphDuration) !== Math.floor((animationTime - 16) / morphDuration)) {
                currentColor = nextColor;
                nextColor = getRandomColor();
            }
            
            switch (phase) {
                case 0: // Circle to Square
                    fromPoints = getCirclePoints();
                    toPoints = getSquarePoints();
                    break;
                case 1: // Square to Triangle
                    fromPoints = getSquarePoints();
                    toPoints = getTrianglePoints();
                    break;
                case 2: // Triangle to Circle
                    fromPoints = getTrianglePoints();
                    toPoints = getCirclePoints();
                    break;
            }
            
            const morphedPoints = morphPoints(fromPoints, toPoints, t);
            drawShape(morphedPoints, currentColor);
            
            animationTime += 16;
            requestAnimationFrame(animate);
        }
        
        // Start animation
        animate();

// ------ Random Favicon System ------ //
const favicons = [
    '../icons/shapes/RedCircle.png',
    '../icons/shapes/OrangeCircle.png',
    '../icons/shapes/YellowCircle.png',
    '../icons/shapes/GreenCircle.png',
    '../icons/shapes/CyanCircle.png',
    '../icons/shapes/BlueCircle.png',
    '../icons/shapes/PurpleCircle.png',
    '../icons/shapes/VioletCircle.png',
    '../icons/shapes/FollyCircle.png',

    '../icons/shapes/RedSquare.png',
    '../icons/shapes/OrangeSquare.png',
    '../icons/shapes/YellowSquare.png',
    '../icons/shapes/GreenSquare.png',
    '../icons/shapes/CyanSquare.png',
    '../icons/shapes/BlueSquare.png',
    '../icons/shapes/PurpleSquare.png',
    '../icons/shapes/VioletSquare.png',
    '../icons/shapes/FollySquare.png',

    '../icons/shapes/RedTriangle.png',
    '../icons/shapes/OrangeTriangle.png',
    '../icons/shapes/YellowTriangle.png',
    '../icons/shapes/GreenTriangle.png',
    '../icons/shapes/CyanTriangle.png',
    '../icons/shapes/BlueTriangle.png',
    '../icons/shapes/PurpleTriangle.png',
    '../icons/shapes/VioletTriangle.png',
    '../icons/shapes/FollyTriangle.png',
];

const randomIcon = favicons[Math.floor(Math.random() * favicons.length)];
const newFavicon = document.createElement('link');
newFavicon.rel = 'icon';
newFavicon.type = 'image/png';
newFavicon.href = randomIcon;

const oldIcons = document.querySelectorAll('link[rel="icon"], link[rel="shortcut icon"]');
oldIcons.forEach(icon => icon.remove());

document.head.appendChild(newFavicon);
    </script>
</body>
</html>